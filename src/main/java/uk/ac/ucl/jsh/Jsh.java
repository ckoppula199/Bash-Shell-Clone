/*
COMP0010 SOFTWARE ENGINEERING COURSEWORK UCL 2019

Members: Chakradhar Koppula, Farhan Mahmood, Samuel Emilolorun

Notes: Please see README for additional info on running the project, extra fnuctionality and extra applications
*/


package uk.ac.ucl.jsh;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.misc.ParseCancellationException;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;



public class Jsh {

    private static String currentDirectory = System.getProperty("user.dir");
    private String lastCommand = ""; //stores the last command entered by the user for use in the !! feature
    public static final Charset encoding = StandardCharsets.UTF_8;
    
    public static String getCurrentDirectory() {
        return currentDirectory;
    }

    public static void setCurrentDirectory(String currentDirectory) {
        Jsh.currentDirectory = currentDirectory;
    }

    /**
     * Takes the text passed to the shell and generates the parse tree for the command. The parse tree is then passed to
     * the AntlrParseTreeVisitor to be proccessed into a Command like Call, Seq or Pipe. The accept method is then called on this
     * Command and a CommandVisitor passed to the method. This then executes the applications behaviour and evaluates the command.
     * 
     * @param cmdline command to be executed
     * @param output  OutputStream to be written to
     * @throws IOException exception thrown by BufferedWriter because of something like a closed pipe
     */

    public void eval(String cmdline, OutputStream output) throws IOException {
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output));

        cmdline = previousCommandSubstitution(cmdline, writer);
        lastCommand = cmdline;

        if (cmdline.isBlank()) return;
        cmdline = cmdline.trim();

        GrammarParser parser = createParser(cmdline);
        ParseTree parseTree = parseCommand(parser, writer);

        if (parseTree == null) return;

        AntlrParseTreeVisitor visitor = new AntlrParseTreeVisitor();
        Command command = visitor.visit(parseTree);
        CommandVisitor evaluate = new Evaluate(output, null);
        command.accept(evaluate);
    }

    /**
     * Checks to see if the previous command substitution token is present and replaces every occurence of it with
     * the previous command.
     * 
     * @param cmdline current command to be evaluated
     * @param writer The BufferedWriter used to output the substituted command to be executed
     * @return current command with previous command substituted in place of !!
     * @throws IOException exception thrown by BufferedWriter because of something like a closed pipe
     */
    private String previousCommandSubstitution(String cmdline, BufferedWriter writer) throws IOException {
        String previousCommandString = cmdline.replaceAll("!!", lastCommand);
        if(!previousCommandString.equals(cmdline)) {
            writer.write(previousCommandString);
            writer.write(System.getProperty("line.separator"));
            writer.flush();
        }
        return previousCommandString;
    }

    /**
     * Attempts to construct the parse tree for the given command. If the command cannot be parsed then the error message 
     * genrated by ANTLR is outputted.
     * 
     * @param parser The parser used to parse the command
     * @param writer The BufferedWriter used to output the error produced by ANTLR
     * @return The ParseTree generated by ANTLR
     * @throws IOException exception thrown by BufferedWriter because of something like a closed pipe
     */
    private ParseTree parseCommand(GrammarParser parser, BufferedWriter writer) throws IOException {
        try {
            return parser.start();
        } catch (ParseCancellationException e) {
            writer.write(e.getMessage());
            writer.write(System.getProperty("line.separator"));
            writer.flush();
            return null;
        }
    }

    /**
     * Takes the command and puts it through the Lexer and returns the Parser generated by ANTLR
     * 
     * @param cmdline command to be executed.
     * @return The Parser generated by ANTLR
     */
    private GrammarParser createParser(String cmdline) {
        CharStream charStream = CharStreams.fromString(cmdline);
        GrammarLexer lexer = new GrammarLexer(charStream);
        CommonTokenStream commonTokenStream = new CommonTokenStream(lexer);
        GrammarParser parser = new GrammarParser(commonTokenStream);
        parser.removeErrorListeners();
        parser.addErrorListener(ErrorListener.INSTANCE);
        return parser;
    }

    public static void main(String[] args) {
        Jsh jsh = new Jsh();
        if (args.length > 0) {
            testCommandLineArgs(args);
            try {
                jsh.eval(args[1], System.out);
            } catch (Exception e) {
                System.out.println("jsh: " + e.getMessage());
            }
        } else {
            try (Scanner input = new Scanner(System.in)) {
                prompt(jsh, input);
            }
        }
    }

    /**
     * Tests the two arguments after ./jsh is run.
     *
     * @param args - an array list of argument on the bash command line
     */
    private static void testCommandLineArgs(String[] args) {
        if (args.length != 2) {
            System.out.println("jsh: wrong number of arguments");
            return;
        }
        if (!args[0].equals("-c")) {
            System.out.println("jsh: " + args[0] + ": unexpected argument");
        }
    }

    /**
     * Prompts the user of the jsh command Line after return is hit. Eveluates the text passed
     * to the command line and then returns waiting for the next input.
     *
     * @param jsh   - the shell object
     * @param input - An input stream taking input from the jsh command line.
     */

    private static void prompt(Jsh jsh, Scanner input) {
        while (true) {
            String promptLine = Jsh.currentDirectory + "> ";
            System.out.print(promptLine);
            try {
                String cmdline = input.nextLine();
                jsh.eval(cmdline, System.out);
            } catch (Exception e) {
                System.out.println("jsh: " + e.getMessage());
            }
        }
    }
}
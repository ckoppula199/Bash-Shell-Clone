package uk.ac.ucl.jsh;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.antlr.v4.runtime.tree.ParseTree;

import uk.ac.ucl.jsh.GrammarParser.ArgumentContext;
import uk.ac.ucl.jsh.GrammarParser.BackquotedContext;
import uk.ac.ucl.jsh.GrammarParser.RedirectionContext;

/**
 * Class Description
 * 
 * This Class describes a visitor that visits every node in the Abstract Syntax tree (AST) generated by Antlr4
 * The overriden methods define what happens at each node Y, where a command can be extracted from its children by
 * calling the accept method and node Y can also return a command to its parent. A user class can create an object of this class
 * and call the visit function with the antlr AST as an argument, returning a command to the user. Whenever the visitor is in a call node,
 * its children will always return a call object to it so type casting is required to differentiate this command. At pipe or seq, 
 * the visitor isn't sure which command is returned (could be pipe,seq or call) so this is resolved at runtime.
 *
 */

public class AntlrParseTreeVisitor extends GrammarBaseVisitor<Command> {

    private String fileInputName = null;
    private String fileOutputName = null;
    private boolean multipleInputFiles = false;
    private boolean multipleOutputFiles = false;
    private InputStream inputCommandSubstitution;
    private OutputStream outputCommandSubstitution;


    @Override
    public Command visitCall(GrammarParser.CallContext context) {
        ArrayList<String> tokens = new ArrayList<>();
        List<ArgumentContext> argumentList = context.argument();
        List<RedirectionContext> redirectionList = context.redirection();

        for (int i = 0; i < argumentList.size(); i++) {
            //cast is safe as result of calling accept on an argument will always be of type Call
            Call call = (Call) argumentList.get(i).accept(this);
            if (call.isExpandable()) {
                tokens.addAll(call.getCommandLineArgs());
            } else {
                tokens.add(call.getArgument());
            }
        }

        for (int i = 0; i < redirectionList.size(); i++) {
            redirectionList.get(i).accept(this);
        }
        return new Call(tokens, fileInputName, fileOutputName);
    }


    @Override
    public Command visitSeq(GrammarParser.SeqContext context) {
        Command left = context.getChild(0).accept(this);
        resetRedirectionSettings();
        Command right = context.getChild(2).getChild(0).accept(this);

        return new Seq(left, right);
    }

    @Override
    public Command visitPipe(GrammarParser.PipeContext context) {
        Command left = context.getChild(0).accept(this);
        resetRedirectionSettings();
        Command right = context.getChild(2).accept(this);

        return new Pipe(left, right);
    }

    @Override
    public Command visitArgument(GrammarParser.ArgumentContext context) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < context.getChildCount(); i++) {
            //cast is safe as result of calling accept on an argument will always be of type Call
            Call child = (Call) context.getChild(i).accept(this);
            if (child.isExpandable()) {
                if (context.getChildCount() == 1) {
                    Call call = new Call(child.getCommandLineArgs());
                    return call;
                }
                sb.append(listToString(child.getCommandLineArgs()));
                continue;
            }
            sb.append(child.getArgument());
        }
        return new Call(sb.toString());
    }

    @Override
    public Command visitRedirection(GrammarParser.RedirectionContext context) {
        String sign = context.getChild(0).getText();
        // cast is safe as result of calling accept on redirection will always be of type call
        Call call = (Call) context.getChild(context.getChildCount() - 1).accept(this);
        if ("<".equals(sign)) {
            if (!this.multipleInputFiles) {
                this.multipleInputFiles = true;
                this.fileInputName = getFileName(call);
            } else {
                throw new RuntimeException("IO redirection: more than 1 file specified for input redirection");
            }
        } else {
            if (!this.multipleOutputFiles) {
                this.multipleOutputFiles = true;
                this.fileOutputName = getFileName(call);
            } else {
                throw new RuntimeException("IO redirection: than 1 file specified for output redirection");
            }
        }
        return null;
    }


    @Override
    public Command visitUnquoted(GrammarParser.UnquotedContext context) {
        ArrayList<String> globbingResult = checkForGlobbiing(context.getText());
        Call call = new Call(globbingResult);
        return call;
    }

    @Override
    public Command visitSinglequoted(GrammarParser.SinglequotedContext context) {
        String text = context.getText();
        Call call = new Call(text.substring(1, text.length() - 1));
        return call;
    }

    @Override
    public Command visitBackquoted(GrammarParser.BackquotedContext context) {
        String text = context.getText();
        String[] results = performSubCommand(text);
        Call call = new Call(Arrays.asList(results));
        return call;
    }

    @Override
    public Command visitDoublequoted(GrammarParser.DoublequotedContext context) {
        StringBuilder sb = new StringBuilder();
        List<BackquotedContext> backquoteList = context.backquoted();
        for (int i = 1; i < context.getChildCount() - 1; i++) {
            ParseTree tree = context.getChild(i);
            if (backquoteList.contains(tree)) {
                Call call = (Call) context.getChild(i).accept(this);
                sb.append(listToString(call.getCommandLineArgs()));
            } else {
                sb.append(tree.getText());
            }

        }
        return new Call(sb.toString());
    }

    private String listToString(List<String> aList) {
        StringBuilder sb = new StringBuilder();
        int i = 0;
        for (; i < aList.size() - 1; i++) {
            sb.append(aList.get(i));
            sb.append(" ");
        }
        sb.append(aList.get(i));
        return sb.toString();
    }

    /**
     * Expands potential * in the nonQuote into multiple arguments
     * @param nonQuote
     * @return - A list of Paths in string format according to the potential globbing syntax in nonQuote
     */
    private ArrayList<String> checkForGlobbiing(String nonQuote) {
        String[] directories = nonQuote.split("/");
        String glob = directories[directories.length - 1];
        directories[directories.length - 1] = "";
        Path dir = Paths.get(Jsh.getCurrentDirectory(), directories);
        return getGlobbingResult(nonQuote, dir, glob, directories);
    }

    private ArrayList<String> getGlobbingResult(String nonQuote, Path dir, String glob, String[] directories) {
        ArrayList<String> globbingResult = new ArrayList<>();
        try {
            DirectoryStream<Path> stream = Files.newDirectoryStream(dir, glob);
            for (Path entry : stream) {
                String directoryElement = entry.getFileName().toString();
                if (directoryElement.startsWith(".")) continue;
                globbingResult.add(makeRelativePath(directories, directoryElement));
            }
        } catch (IOException e) {
            assert true;
        }

        if (globbingResult.isEmpty()) {
            globbingResult.add(nonQuote);
        }
        return globbingResult;
    }


    private String makeRelativePath(String[] directories, String directoryElement) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < directories.length; i++) {
            if (!"".equals(directories[i])) {
                sb.append(directories[i] + File.separator);
            }
        }

        return sb.append(directoryElement).toString();
    }


    private String[] performSubCommand(String backQuotedStr) {
        String subCommand = backQuotedStr.substring(1, backQuotedStr.length() - 1);
        Jsh jsh = new Jsh();
        String[] results = null;
        this.inputCommandSubstitution = new PipedInputStream(100000);
        try {
            results = auxPerformSubCommand(jsh, subCommand);

        } catch (Exception e) {
            throw new RuntimeException("Command Substitution Error " + e.getMessage());
        }
        return results;
    }

    private String[] auxPerformSubCommand(Jsh jsh, String subCommand) throws IOException {
        this.outputCommandSubstitution = new PipedOutputStream((PipedInputStream) this.inputCommandSubstitution);
        jsh.eval(subCommand, this.outputCommandSubstitution);
        this.outputCommandSubstitution.close();
        String line = new String(this.inputCommandSubstitution.readAllBytes()).replace(System.getProperty("line.separator"), " ");
        String[] str = line.split("[ \t]");
        return str;
    }

    /**
     * returns the fileName from a call object depending on whether the call object was made through globbing/command substiution
     * (expandable) or not.
     */
    private String getFileName(Call call) {
        if (call.isExpandable()) {
            List<String> arguments = call.getCommandLineArgs();
            if (arguments.size() > 1) {
                throw new RuntimeException("Ambiguous Redirect");
            } else {
                return arguments.get(0);
            }
        }
        return call.getArgument();
    }

    private void resetRedirectionSettings() {
        this.fileInputName = null;
        this.fileOutputName = null;
        this.multipleInputFiles = false;
        this.multipleOutputFiles = false;
    }

}
